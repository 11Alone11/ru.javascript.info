# Копирование объектов и ссылки

Одно из принципиальных отличий объектов от примитивных типов данных в том, что они хранятся и копируются "по ссылке".

Примитивные значения (строки, числа, булевы) присваиваются/копируются "как есть".

К примеру:

```js
let message = "Привет!";
let phrase = message;
```

В результате выполнения этого кода у нас есть две независимые друг от друга переменные, каждая из которых содержит строку `"Привет!"`.

![](variable-copy-value.svg)

Объекты работают иначе.

**Переменная хранит не сам объект, а его "адрес в памяти", т.е. "ссылку" на него.**.

Давайте проиллюстрируем это: 

```js
let user = {
  name: "Иван"
};
```

![](variable-contains-reference.svg)

**When an object variable is copied -- the reference is copied, the object is not duplicated.**

В данном случае объект сохраняется где-то в памяти, а переменная `user` хранит "ссылку" на него.

**Когда переменная с объектом копируется, копируется ссылка на него, т.е. сам объект при этом не дублируется.**

Например:

```js no-beautify
let user = { name: "Иван" };

let admin = user; // копирование по ссылке
```

Теперь у нас две переменные, каждая из которых ссылается на один и тот же объект:

![](variable-copy-reference.svg)

Можно использовать любую переменную, чтобы обратиться к объекту, а также изменить его содержимое:

```js run
let user = { name: 'Иван' };

let admin = user;

*!*
admin.name = 'Петя'; // изменяем значение через ссылку "admin"
*/!*

alert(*!*user.name*/!*); // 'Петя', сделанные изменения видны по ссылке "user"
```

Вышеприведённый пример показывает, что есть только один объект. Это как если бы у нас был шкаф с двумя ключами и мы использовали один из них (`admin`), чтобы открыть его. А потом используем другой ключ (`user`), чтобы увидеть изменения.

## Сравнение по ссылке

Операторы равенства `==` и строгого равенства `===` для объектов работают одинаково.

**Два объекта равны только в том случае, если это один и тот же объект.**

В примере ниже две переменные ссылаются на один и тот же объект, поэтому они равны друг другу:

```js run
let a = {};
let b = a; // копирование по ссылке

alert( a == b ); // true, т.к. обе переменные ссылаются на один и тот же объект
alert( a === b ); // true
```

В другом примере два разных объекта не равны, хотя оба пусты:

```js run
let a = {};
let b = {}; // два независимых объекта

alert( a == b ); // false
```

Для сравнений типа `obj1 > obj2` или для сравнения с примитивом `obj == 5` объекты преобразуются в примитивы. Мы скоро изучим, как работают такие преобразования объектов, но, по правде говоря, сравнения такого рода необходимы очень редко и обычно являются результатом ошибки программиста.

## Клонирование и объединение объектов, Object.assign

Таким образом, при копировании переменной с объектом создаётся ещё одна ссылка на тот же самый объект.

Но что, если нам всё же нужно дублировать объект? Создать независимую копию, клон?

Это выполнимо, но немного сложно, так как в JavaScript нет встроенного метода для этого. На самом деле, такая нужда возникает редко. В большинстве случаев нам достаточно копирования по ссылке.

Но если мы действительно этого хотим, то нам нужно создавать новый объект и повторять структуру дублируемого объекта, перебирая его свойства и копируя их.

Например так:

```js run
let user = {
  name: "Иван",
  age: 30
};

*!*
let clone = {}; // новый пустой объект

// скопируем все свойства user в него
for (let key in user) {
  clone[key] = user[key];
}
*/!*

// теперь в переменной clone находится абсолютно независимый клон объекта
clone.name = "Пётр"; // изменим в нём данные

alert( user.name ); // в оригинальном объекте значение свойства `name` осталось прежним – Иван.
```

Кроме того, для этих целей мы можем использовать метод [Object.assign](mdn:js/Object/assign).

Синтаксис:

```js
Object.assign(dest, [src1, src2, src3...])
```

- Первый аргумент `dest` — целевой объект.
- Остальные аргументы `src1, ..., srcN` (может быть столько, сколько нужно)) являются исходными объектами
- Метод копирует свойства всех исходных объектов `src1, ..., srcN` в целевой объект `dest`.  То есть, свойства всех перечисленных объектов, начиная со второго, копируются в первый объект.
- Возвращает объект `dest`.

Например, объединим несколько объектов в один:
```js
let user = { name: "Иван" };

let permissions1 = { canView: true };
let permissions2 = { canEdit: true };

*!*
// копируем все свойства из permissions1 и permissions2 в user
Object.assign(user, permissions1, permissions2);
*/!*

// теперь user = { name: "John", canView: true, canEdit: true }
```

Если принимающий объект (`user`) уже имеет свойство с таким именем, оно будет перезаписано:

```js run
let user = { name: "Иван" };

Object.assign(user, { name: "Пётр" });

alert(user.name); // теперь user = { name: "Пётр" }
```

Мы также можем использовать `Object.assign` для замены `for..in` на простое клонирование:

```js
let user = {
  name: "Иван",
  age: 30
};

*!*
let clone = Object.assign({}, user);
*/!*
```

Этот метод скопирует все свойства объекта `user` в пустой объект и возвратит его.

## Вложенное клонирование

До сих пор мы предполагали, что все свойства объекта `user` хранят примитивные значения. Но свойства могут быть ссылками на другие объекты. Что с ними делать?

Например, есть объект:
```js run
let user = {
  name: "Иван",
  sizes: {
    height: 182,
    width: 50
  }
};

alert( user.sizes.height ); // 182
```

Теперь при клонировании недостаточно просто скопировать `clone.sizes = user.sizes`, поскольку `user.sizes` - это объект, он будет скопирован по ссылке. А значит объекты `clone` и `user` в своих свойствах `sizes` будут ссылаться на один и тот же объект:

```js run
let user = {
  name: "Иван",
  sizes: {
    height: 182,
    width: 50
  }
};

let clone = Object.assign({}, user);

alert( user.sizes === clone.sizes ); // true, один и тот же объект

// user и clone обращаются к одному sizes
user.sizes.width++;       // меняем свойство в одном объекте
alert(clone.sizes.width); // 51, видим результат в другом объекте
```

Чтобы исправить это, мы должны в цикле клонирования делать проверку, не является ли значение `user[key]` объектом, и если это так - скопировать и его структуру тоже. Это называется "глубокое клонирование".

Мы можем реализовать глубокое клонирование, используя рекурсию. Или, чтобы не изобретать велосипед, использовать готовую реализацию — метод [_.cloneDeep(obj)](https://lodash.com/docs#cloneDeep) из JavaScript-библиотеки [lodash](https://lodash.com).

## Итого

Объекты присваиваются и копируются по ссылке. Другими словами, переменная хранит не "значение объекта", а "ссылку" (адрес в памяти) на это значение. Поэтому копирование такой переменной или передача её в качестве аргумента функции приводит к копированию этой ссылки, а не самого объекта.

Все операции с использованием скопированных ссылок (например, добавление или удаление свойств) выполняются с одним и тем же объектом.

Для "простого клонирования" объекта можно использовать `Object.assign`. Необходимо помнить, что `Object.assign` не делает глубокое клонирования объекта. Если внутри копируемого объекта есть свойство значение, которого не является примитивом, оно будет передано по ссылке. Для создания "настоящей копии" (полного клона объекта) можно воспользоваться методом из сторонней JavaScript-библиотеки [_.cloneDeep(obj)](https://lodash.com/docs#cloneDeep).