# Конструктор, оператор "new"

Обычный синтаксис `{...}` позволяет создать только один объект. Но зачастую нам нужно создать множество похожих, однотипных объектов, таких как множе пользователи, элементы меню и так далее.

Это можно сделать при помощи функции-конструктора и оператора `"new"`.

## Функция-конструктор

Функции-конструкторы технически являются обычными функциями. Однако есть два соглашения:

1. Имя функции-конструктора должно начинаться с большой буквы.
2. Они должны выполняться только с помощью оператора `"new"`.

Например:

```js run
function User(name) {
  this.name = name;
  this.isAdmin = false;
}

*!*
let user = new User("Jack");
*/!*

alert(user.name); // Jack
alert(user.isAdmin); // false
```

Когда функция выполняется с помощью `new`, она выполняет следующие действия:

1. Создаётся новый пустой объект, которому присваивается значение `this`.
2. Выполняется тело функции. Обычно он модифицирует `this`, добавляя туда новые свойства.
3. Возвращается значение `this`.

Другими словами, `new User(...)` делает что-то вроде:

```js
function User(name) {
*!*
  // this = {};  (неявно)
*/!*

  // добавляет свойства к this
  this.name = name;
  this.isAdmin = false;

*!*
  // return this;  (неявно)
*/!*
}
```

Таким образом, `let user = new User("Jack")` даёт тот же результат, что и:

```js
let user = {
  name: "Jack",
  isAdmin: false
};
```

Теперь, если нам будет необходимо создать других пользователей, мы можем просто вызвать `new User("Ann")`, `new User("Alice")` и так далее. Данная конструкция гораздо удобнее и читабельнее, чем каждый раз создавать литерал объекта. 

Это и есть основная цель конструкторов - реализовать код для многократного создания однотипных объектов.

Давайте ещё раз отметим - технически любая функция (кроме функций со стрелками, поскольку у них нет `this`) может использоваться в качестве конструктора. Его можно запустить с помощью `new`, и он выполнит выше указанный алгоритм. Должна начинаться с "заглавной буквы" - это общее соглашение, чтобы было ясно, что функция должна вызываться с помощью "new".

````smart header="new function() { ... }"
Если у нас есть много строк кода, посвящённых созданию одного сложного объекта, мы можем обернуть их в немедленно вызываемую функцию-конструктор, вот так:

```js
// создаём функцию и сразу же вызываем её с помощью new
let user = new function() { 
  this.name = "John";
  this.isAdmin = false;

  // ...другой код для создания пользователя
  // может быть, сложная логика и инструкции
  // локальные переменные и так далее
};
```

Такой конструктор не может быть вызван снова, так как он нигде не сохраняется, просто создаётся и тут же вызывается. Таким образом, этот трюк направлен на инкапсуляцию кода, который создаёт отдельный объект, без возможности повторного использования в будущем.
````

## Проверка на вызов в режиме конструктора: new.target

```smart header="Продвинутая возможность"
Синтаксис из этого раздела используется крайне редко, пропустите его, если не хотите углубляться вo все детали языка.
```

Используя специальное свойство `new.target` внутри функции, мы можем проверить, вызвана ли функция при помощи оператора `new` или без него.

Он будет `undefined` для обычных вызовов и равен функции, если вызывается с помощью `new`:

```js run
function User() {
  alert(new.target);
}

// без "new":
*!*
User(); // undefined
*/!*

// с "new":
*!*
new User(); // function User { ... }
*/!*
```

Это можно использовать внутри функции, чтобы узнать, была ли она вызвана при `new`, "в режиме конструктора", или без него, "в обычном режиме".

Мы также можем сделать чтобы `new` и обычные вызовы делали то же самое, как-то так:

```js run
function User(name) {
  if (!new.target) { // в случае, если вы вызвали меня без оператора new
    return new User(name); // ...я добавлю new за вас
  }

  this.name = name;
}

let john = User("John"); // переадресовывает вызовы на new User
alert(john.name); // John
```

Такой подход иногда используется в библиотеках, чтобы сделать синтаксис более гибким. Так чтобы люди могли вызывать функцию с "new" или без него, и она все ещё могла работать.

Впрочем вероятно, это не очень хорошая практика использовать этот трюк везде, так как опуск `new` делает немного менее очевидным то, что происходит. С помощью `new` мы все знаем, что создаётся новый объект.

## Возврат значения из конструктора return

Обычно конструкторы не имеют `return`. Их задача - записать все необходимое в `this`, и это автоматически становится результатом.

Но если `return` всё же есть, то применяется простое правило:

- При вызове `return` с объектом, вместо `this` возвращается объект.
- При вызове `return` с примитивным значением, оно игнорируется.

Другими словами, `return` с объектом возвращает этот объект, во всех остальных случаях возвращается `this`.

К примеру, здесь `return` замещает `this`, возвращая объект:

```js run
function BigUser() {

  this.name = "John";

  return { name: "Godzilla" };  // <-- возвращает этот объект
}

alert( new BigUser().name );  // Godzilla, получили этот объект
```

А вот пример с пустым `return` (или мы могли бы поставить примитив после `return`, неважно):

```js run
function SmallUser() {

  this.name = "John";

  return; // <-- возвращает this
}

alert( new SmallUser().name );  // John
```

Обычно у конструкторов отсутствует `return`. Здесь мы упоминаем об особом поведении с возвращаемыми объектами в основном для полноты картины.

````smart header="Опуск скобок"
Кстати, мы можем не ставить круглые скобки после `new`, если у него нет аргументов:

```js
let user = new User; // <-- без скобок
// то же, что и
let user = new User();
```

Пропуск здесь не считается "хорошим стилем", но такой синтаксис разрешён спецификацией.
````

## Создание методов в конструкторе

Использование функций конструктора для создания объектов обеспечивает большую гибкость. Функции-конструкторы могут иметь параметры, определяющие, как создавать объект и что в него помещать.

Конечно, мы можем добавить к `this` не только свойства, но и методы.

Например, `new User(name)` ниже создаёт объект с заданным `name` и методом `sayHi`:

```js run
function User(name) {
  this.name = name;

  this.sayHi = function() {
    alert( "Меня зовут: " + this.name );
  };
}

*!*
let john = new User("John");

john.sayHi(); // Меня зовут: John
*/!*

/*
john = {
   name: "John",
   sayHi: function() { ... }
}
*/
```

Для создания сложных объектов существует более продвинутый синтаксис, [классы](info:classes), который мы рассмотрим позже.

## Итого

- Функции-конструкторы или просто конструкторы, являются обычными функциями, но существует общее соглашение именовать их с заглавной буквы.
- Функции-конструкторы следует вызывать только с помощью `new`. Такой вызов подразумевает создание пустого `this` в начале и возврат заполненного в конце.

Мы можем использовать конструкторы для создания множества похожих объектов.

JavaScript предоставляет функции-конструкторы для множества встроенных объектов языка: таких как `Date` для дат, `Set` для наборов и других, которые нам ещё предстоит изучить.

```smart header="Объекты, we'll be back! (мы ещё вернёмся!)"
В этой главе мы рассмотрели только основы объектов и конструкторов. Данная информация необходима нам для дальнейшего изучения типов данных и функций в последующих главах.

После того, как мы с этим разберёмся, мы вернёмся к объектам для более детального изучения в главах <info:prototypes> и <info:classes>.
```
