# Операторы сравнения

<<<<<<< HEAD:1-js/02-first-steps/08-comparison/article.md
Многие операторы сравнения известны нам из математики:

- Больше/меньше: <code>a &gt; b</code>, <code>a &lt; b</code>.
- Больше/меньше или равно: <code>a &gt;= b</code>, <code>a &lt;= b</code>.
- Равно: `a == b`. Обратите внимание, для сравнения используется двойной знак равенства `=`. Один знак равенства `a = b` означал бы присваивание.
- Не равно. В математике обозначается символом <code>&ne;</code>. В JavaScript записывается как знак равенства с предшествующим ему восклицательным знаком: <code>a != b</code>.
=======
We know many comparison operators from maths.

In JavaScript they are written like this:

- Greater/less than: <code>a &gt; b</code>, <code>a &lt; b</code>.
- Greater/less than or equals: <code>a &gt;= b</code>, <code>a &lt;= b</code>.
- Equals: `a == b`, please note the double equality sign `=` means the equality test, while a single one `a = b` means an assignment.
- Not equals. In maths the notation is <code>&ne;</code>, but in JavaScript it's written as <code>a != b</code>.

In this article we'll learn more about different types of comparisons, how JavaScript makes them, including important peculiarities. 

At the end you'll find a good recipe to avoid "javascript quirks"-related issues.
>>>>>>> 340ce4342100f36bb3c4e42dbe9ffa647d8716c8:1-js/02-first-steps/09-comparison/article.md

## Результат сравнения имеет логический тип

<<<<<<< HEAD:1-js/02-first-steps/08-comparison/article.md
Операторы сравнения, как и другие операторы, возвращают значение. Это значение имеет логический тип.
=======
All comparison operators return a boolean value:
>>>>>>> 340ce4342100f36bb3c4e42dbe9ffa647d8716c8:1-js/02-first-steps/09-comparison/article.md

- `true` -- означает "да", "верно", "истина".
- `false` -- означает "нет", "неверно", "ложь".

Например:

```js run
<<<<<<< HEAD:1-js/02-first-steps/08-comparison/article.md
alert( 2 > 1 );  // true (верно)
alert( 2 == 1 ); // false (неверно)
alert( 2 != 1 ); // true (верно)
```
=======
alert( 2 > 1 );  // true (correct)
alert( 2 == 1 ); // false (wrong)
alert( 2 != 1 ); // true (correct)
``` 
>>>>>>> 340ce4342100f36bb3c4e42dbe9ffa647d8716c8:1-js/02-first-steps/09-comparison/article.md

Результат сравнения можно присвоить переменной, как и любое значение:

```js run
let result = 5 > 4; // результат сравнения присваивается переменной result
alert( result ); // true
```

## Сравнение строк

Чтобы определить, что одна строка больше другой, JavaScript использует "алфавитный" или "лексикографический" порядок.

Другими словами, строки сравниваются посимвольно.

Например:

```js run
alert( 'Я' > 'А' ); // true
alert( 'Кот' > 'Код' ); // true
alert( 'Сонный' > 'Сон' ); // true
```

Алгоритм сравнения двух строк довольно прост:

1. Сначала сравниваются первые символы строк.
2. Если первый символ первой строки больше (меньше), чем первый символ второй, то первая строка больше (меньше) второй.
3. Если первые символы равны, то таким же образом сравниваются уже вторые символы строк.
4. Сравнение продолжается, пока не закончится одна из строк.
5. Если обе строки заканчиваются одновременно, то они равны. Иначе, большей считается более длинная строка.

В примерах выше сравнение `'Я' > 'А'` завершится на первом шаге, тогда как строки `"Кот"` и `"Код"` будут сравниваться посимвольно:

1. `К` равна `К`.
2. `о` равна `о`.
3. `т` больше чем `д`. На этом сравнение заканчивается. Первая строка больше.

```smart header="Используется кодировка Unicode, а не настоящий алфавит"
Приведённый выше алгоритм сравнения похож на алгоритм, используемый в словарях и телефонных книгах, но между ними есть и различия.

Например, в JavaScript имеет значение регистр символов. Заглавная буква `"A"` не равна строчной `"a"`. Какая же из них больше? Строчная `"a"`. Почему? Потому что строчные буквы имеют больший код во внутренней таблице кодирования, которую использует JavaScript (Unicode). Мы ещё поговорим о внутреннем представлении строк и его влиянии в главе <info:string>.
```

## Сравнение разных типов

При сравнении значений разных типов JavaScript приводит каждое из них к числу.

Например:

```js run
alert( '2' > 1 ); // true, строка '2' становится числом 2
alert( '01' == 1 ); // true, строка '01' становится числом 1
```

Логическое значение `true` становится `1`, а `false` – `0`.

Например:

```js run
alert( true == 1 ); // true
alert( false == 0 ); // true
```

````smart header="Забавное следствие"
Возможна следующая ситуация:

- Два значения равны.
- Одно из них `true` как логическое значение, другое – `false`.

Например:

```js run
let a = 0;
alert( Boolean(a) ); // false

let b = "0";
alert( Boolean(b) ); // true

alert(a == b); // true!
```

С точки зрения JavaScript, результат ожидаем. Равенство преобразует значения, используя числовое преобразование, поэтому `"0"` становится `0`. В то время как явное преобразование с помощью `Boolean` использует другой набор правил.
````

## Строгое сравнение

Использование обычного сравнения `==` может вызывать проблемы. Например, оно не отличает `0` от `false`:

```js run
alert( 0 == false ); // true
```

Та же проблема с пустой строкой:

```js run
alert( '' == false ); // true
```

Это происходит из-за того, что операнды разных типов преобразуются оператором `==` к числу. В итоге, и пустая строка, и `false` становятся нулём.

Как же тогда отличать `0` от `false`?

**Оператор строгого равенства `===` проверяет равенство без приведения типов.**

Другими словами, если `a` и `b` имеют разные типы, то проверка `a === b` немедленно возвращает `false` без попытки их преобразования.

Давайте проверим:

```js run
alert( 0 === false ); // false, так как сравниваются разные типы
```

Ещё есть оператор строгого неравенства `!==`, аналогичный `!=`.

Оператор строгого равенства дольше писать, но он делает код более очевидным и оставляет меньше мест для ошибок.

## Сравнение с null и undefined

Поведение `null` и `undefined` при сравнении с другими значениями - особое:

При строгом равенстве `===`
: Эти значения различны, так как различны их типы.

    ```js run
    alert( null === undefined ); // false
    ```

При нестрогом равенстве `==`
: Эти значения равны друг другу и не равны никаким другим значениям. Это специальное правило языка.

    ```js run
    alert( null == undefined ); // true
    ```

При использовании математических операторов и других операторов сравнения `< > <= >=`
: Значения `null/undefined` преобразуются к числам: `null` становится `0`, а `undefined` – `NaN`.

Посмотрим, какие забавные вещи случаются, когда мы применяем эти правила. И, что более важно, как избежать ошибок при их использовании.

### Странный результат сравнения null и 0

Сравним `null` с нулём:

```js run
alert( null > 0 );  // (1) false
alert( null == 0 ); // (2) false
alert( null >= 0 ); // (3) *!*true*/!*
```

С точки зрения математики это странно. Результат последнего сравнения говорит о том, что "`null` больше или равно нулю", тогда результат одного из сравнений выше должен быть `true`, но они оба ложны.

Причина в том, что нестрогое равенство и сравнения `> < >= <=` работают по-разному. Сравнения преобразуют `null` в число, рассматривая его как `0`. Поэтому выражение (3) `null >= 0` истинно, а `null > 0` ложно.

С другой стороны, для нестрогого равенства `==` значений `undefined` и `null` действует особое правило: эти значения ни к чему не приводятся, они равны друг другу и не равны ничему другому. Поэтому (2) `null == 0` ложно.

### Несравнимое значение undefined

Значение `undefined` несравнимо с другими значениями:

```js run
alert( undefined > 0 ); // false (1)
alert( undefined < 0 ); // false (2)
alert( undefined == 0 ); // false (3)
```

Почему же сравнение `undefined` с нулём всегда ложно?

На это есть следующие причины:

- Сравнения `(1)` и `(2)` возвращают `false`, потому что `undefined` преобразуется в `NaN`, а `NaN` – это специальное числовое значение, которое возвращает `false` при любых сравнениях.
- Нестрогое равенство `(3)` возвращает `false`, потому что `undefined` равно только `null` и ничему больше.

<<<<<<< HEAD:1-js/02-first-steps/08-comparison/article.md
### Как избежать проблем

Зачем мы рассмотрели все эти примеры? Должны ли мы постоянно помнить обо всех этих особенностях? Не обязательно. Со временем все они станут вам знакомы, но можно избежать проблем, если следовать простому правилу.

Просто относитесь к любому сравнению с `undefined/null`, кроме строгого равенства `===`, с осторожностью.

Не используйте сравнения `>= > < <=` с переменными, которые могут принимать значения `null/undefined`, если вы не уверены в том, что делаете. Если переменная может принимать эти значения, то добавьте для них отдельные проверки.
=======
### Avoid problems

Why did we go over these examples? Should we remember these peculiarities all the time? Well, not really. Actually, these tricky things will gradually become familiar over time, but there's a solid way to avoid problems with them:

- Treat any comparison with `undefined/null` except the strict equality `===` with exceptional care.
- Don't use comparisons `>= > < <=` with a variable which may be `null/undefined`, unless you're really sure of what you're doing. If a variable can have these values, check for them separately.
>>>>>>> 340ce4342100f36bb3c4e42dbe9ffa647d8716c8:1-js/02-first-steps/09-comparison/article.md

## Итого

- Операторы сравнения возвращают значения логического типа.
- Строки сравниваются посимвольно в лексикографическом порядке.
- Значения разных типов при сравнении приводятся к числу. Исключением является сравнение с помощью операторов строгого равенства/неравенства.
- Значения `null` и `undefined` равны `==` друг другу и не равны любому другому значению.
- Будьте осторожны при использовании операторов сравнений `>` и `<` с переменными, которые могут принимать значения `null/undefined`. Хорошей идеей будет сделать отдельную проверку на `null/undefined`.
