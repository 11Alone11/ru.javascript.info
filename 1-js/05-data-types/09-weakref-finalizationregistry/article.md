
# WeakRef и FinalizationRegistry

Вспоминая основную концепцию принципа *достижимости* из главы <info:garbage-collection>,
мы можем отметить, что движок JavaScript гарантированно хранит в памяти значения, которые доступны или используются.

Например:

```js
//  в переменной user находится сильная ссылка на объект
let user = { name: "Aleks" };

// перезапишем значение переменной user
user = null;

// ссылка теряется и объект будет удалён из памяти
```
Или же, похожий, но немного усложненный пример с двумя сильными ссылками.
Теперь мы скопировали ссылку из `user` в переменную `admin`.
В этом случае объект `Aleks` имеет две сильные ссылки, ссылающиеся на него - `user` и `admin`:

```js
//  в переменной user находится сильная ссылка на объект
let user = { name: "Aleks" };

*!*
let admin = user;
*/!*

// перезапишем значение переменной user
user = null;

// объект всё ещё доступен через глобальную переменную admin
```
Объект `John` удалился бы из памяти только в случае отсутствия сильных ссылок на него (если бы мы также перезаписали значение переменной `admin`).

В JavaScript существует концепция под названием `WeakRef`, которая ведёт себя немного иначе в этом случае.

## WeakRef

````warn header="Предостережение"

Прежде чем мы перейдём к изучению, стоит отметить, что правильное использование структур, о которых пойдёт речь в этой статье, требует очень тщательного обдумывания, и по возможности их лучше избегать. 

````

`WeakRef` - это объект, содержащий слабую ссылку на другой объект, называемый `target` или `referent`,
который не препятствует сборщику мусора удалять указанный объект.
Другими словами, объект `WeakRef` не удерживает "в живых" объект-референт.  

Теперь давайте возьмём переменную `user` в качестве референта и создадим слабую ссылку от `user` к переменной `admin`.
Чтобы создать слабую ссылку, необходимо использовать конструктор `WeakRef`,
передав целевой объект (объект, на который вы хотите создать слабую ссылку), в нашем случае это переменная `user`:

```js
//  в переменной user находится сильная ссылка на объект
let user = { name: "Aleks" };

//  в переменной admin находится слабая ссылка на объект
*!*
let admin = new WeakRef(user);
*/!*
```

На схеме ниже изображены два типа ссылок: сильная ссылка с использованием переменной `user` и слабая ссылка с использованием переменной `admin`.

![](weakref-finalizationregistry-01.svg)  

Затем, в какой-то момент, мы перестаём использовать переменную `user` - она перезаписывается,
выходит из области видимости и т.д., при этом сохраняя экземпляр `WeakRef` в переменной `admin`:

```js
// перезапишем значение переменной user
user = null;
```

Слабой ссылки на объект недостаточно для того, чтобы сохранить его в живых.
Когда единственными оставшимися ссылками на референт являются слабые ссылки,
сборщик мусора вправе уничтожить объект и использовать его память для чего-то другого.
Однако до тех пор, пока объект фактически не уничтожен, слабая ссылка может вернуть объект, даже если на него больше нет сильных ссылок.
То есть наш объект становится своеобразным "[котом Шрёдингера](https://ru.wikipedia.org/wiki/Кот_Шрёдингера)". Мы не можем точно знать, "жив" он или "мёртв":

![](weakref-finalizationregistry-02.svg)

На этом этапе, чтобы получить объект из экземпляра `WeakRef`, нам нужно использовать его метод `deref()`.
Метод `deref()` возвращает объект-референт или `undefined`, если объект больше не доступен:

```js
let ref = admin.deref();

if (ref) {
  // сделать что-нибудь со значением ref
}
```

## Варианты использования WeakRef

`WeakRef` обычно используется для создания кэшей или сопоставлений (mappings), в которых хранятся массивные объекты,
гарантируя, что простое присутствие объекта в кэше или сопоставлении не гарантирует сохранение этих больших объектов в памяти.
Одним из основных примеров является ситуация, когда у нас есть большое количество объектов бинарных изображений (например, представленных в виде `ArrayBuffer` или `Blob`),
и мы хотим связать имя или путь с каждым изображением. Существующие структуры данных не совсем подходят для этих целей:

- Использование `Map` для создания ассоциаций между именами и изображениями, или наоборот, сохранит объекты изображений в памяти,
  поскольку они фигурируют в `Map` в качестве ключей или значений.
- `WeakMap` также не подходит для этой цели: они слабы по своим ключам, но в данном случае нам нужна структура данных, которая была бы слабой по значениям.

Вместо этого мы можем использовать `Map`, значениями которого являются объекты `WeakRef`, ссылающиеся на необходимые большие объекты.
Следовательно, мы не будем хранить в памяти эти большие и ненужные объекты дольше, чем требуется.
В противном случае это способ получить объект изображения из кэша, если он все еще доступен.
Если же он был удалён сборщиком мусора, -- мы сгенерируем или скачаем его заново.

Таким образом, в некоторых ситуациях используется меньше памяти.  

## Пример №1: применение WeakRef для кеширования

Ниже находится фрагмент кода, который демонстрирует технику использования `WeakRef`.
Говоря кратко, мы используем `Map` со строковыми ключами и объектами `WeakRef` в качестве их значений.
Если объект `WeakRef` не был удалён сборщиком мусора, мы берём его из кэша.
В противном случае мы скачиваем его заново и помещаем в кэш для возможности повторного использования в будущем.

```js
const weakRefCache = (fetchImg) => { // (1)
  const imgCache = new Map(); // (2)
  
  return (imgName) => { // (3)
    const cachedImg = imgCache.get(imgName); // (4)
    
    if (cachedImg?.deref()) { // (5)
      return cachedImg?.deref();
    }

    const newImg = fetchImg(imgName); // (6)
    imgCache.set(imgName, new WeakRef(newImg)); // (7)

    return newImg;
  };
};

const getCachedImg = weakRefCache(fetchImg);
```

Давайте подробно разберём всё, что тут произошло:
- `(1)` `weakRefCache` - функция высшего порядка, которая принимает другую функцию `fetchImg` в качестве аргумента.
- `(2)` `imgCache` - кеш изображений, который хранит кешированные результаты функции `fetchImg`, в виде строковых ключей (имя изображения) и объектов `WeakRef` в качестве их значений.
- `(3)` Возвращаем анонимную функцию, которая принимает имя изображения в качестве аргумента. Данный аргумент будет использоваться в качестве ключа для кэшированного изображения.
- `(4)` Пытаемся получить кешированный результат из кеша, используя предоставленный ключ (имя изображения).
- `(5)` Если кэш содержит значение по указанному ключу, и объект `WeakRef` не был удалён сборщиком мусора, возвращаем закэшированный результат.
- `(6)` Если в кэше нет записи с запрошенным ключом, либо метод `deref()` возвращает `undefined`, что означает, что объект `WeakRef` был удалён сборщиком мусора,
  функция `fetchImg` скачивает изображение заново.
- `(7)` Помещаем скачанное изображение в кэш в виде `WeakRef` объекта.  

Теперь у нас есть коллекция `Map`, в которой ключи - это имена изображений в виде строк, а значения - это объекты `WeakRef`, содержащие сами изображения
Эта техника помогает избежать выделения большого объема памяти на ресурсоёмкие объекты, которые больше никто не использует.
Также она экономит память и время в случае повторного использования кешированных объектов.

Вот визуальное представление того, как выглядит этот код:

![](weakref-finalizationregistry-03.svg) 

Но, у данной реализации есть свои недостатки: со временем `Map` будет заполняться строками в качестве ключей,
которые указывают на `WeakRef`, чей объект-референт уже был удалён сборщиком мусора:

![](weakref-finalizationregistry-04.svg)

Один из способов справиться с этой проблемой - это периодически проверять кэш и удалять "мёртвые" записи.
Другой способ - использование финализаторов, с которыми мы ознакомися далее.  

## Пример №2: применение WeakRef для отслеживания объектов DOM

Ещё один вариант использования `WeakRef` - отслеживание объектов DOM.
Давайте представим ситуацию, когда какой-либо сторонний код или библиотека работает с элементами на нашей странице до тех пор,
пока они существуют в DOM. Например, это может быть сторонний логгер, который присылает события в DOM элемент.
Но как только элемент удаляется из DOM (если, к примеру, мы закрыли окно отображения логов), логгер должен перестать присылать события.
Для того, чтобы нам не присылать лишних событий и не уведомлять сторонний код каждый раз, когда наш элемент доступен и когда он удалён,
достаточно лишь создать на него слабую ссылку. После того как наш элемент будет удалён из DOM (например, если пользователь закроет окно с логами),
логгер это увидит и перестанет присылать данные.

```html run height=120
<div class="events">No events.</div>

<script>
  const startLogger = (element) => {
    const timerId = setInterval(() => {
      // Если элемент существует, шлём логи.
      if (element.deref()) {
        const payload = document.createElement("div");
        payload.textContent = `Event: System status OK: ${new Date().toLocaleTimeString()}`;
        element.deref().appendChild(payload);
      } else {
        // Элемент больше не существует, прекращаем отправку.
        clearInterval(timerId);
        alert("The element has been removed.");
      }
    }, 1000);
  };
  
  // Создаём слабую ссылку на элемент и запускаем логгер.
  const eventsElementRef = new WeakRef(document.querySelector(".events"));
  startLogger(eventsElementRef);

  // Через какое-то время элемент исчезает из DOM.
  setTimeout(() => {
    document.querySelector(".events").remove();
  }, 5000);
</script>
```

## FinalizationRegistry

`FinalizationRegistry` предоставляет способ запросить вызов колбэка очистки (также известный как финализатор) в какой-то момент после того,
как объект, зарегистрированный в реестре, будет собран сборщиком мусора.
Чтобы создать реестр, необходимо вызвать его конструктор, передав функцию очистки (финализатор) в качестве аргумента.

```js run
let user = { name: "Aleks" };

const registry = new FinalizationRegistry((heldValue) => {
  console.log(`${heldValue} has been garbage collected.`);
});
```

Затем, мы регистрируем объект для которого требуется колбэк очистки, вызывая метод `register` и передавая объект и `heldValue` значение для него.
Реестр не хранит сильную ссылку на переданный ему объект, так как это противоречило бы цели (если бы реестр сохранял сильную ссылку на объект, то объект никогда бы не был очищен сборщиком мусора).

```js
registry.register(user, user.name);
```

Если объект был собран сборщиком мусора, наш колбэк очистки может быть вызван в какой-то момент в будущем с переданным ему `heldValue`.
Удерживаемое значение (`heldValue`) может быть любого типа: примитив, объект, даже `undefined`.
Если `heldValue` является объектом, реестр срхраняет на него сильную ссылку (чтобы позже можно было передать его в колбэк очистки).  

![](weakref-finalizationregistry-05.svg)

```js
// Когда объект user будет удалён сборщиком мусора, в консоль будет выведено сообщение:
"Aleks has been garbage collected."
```

Также существуют ситуации, когда даже в реализациях, которые обычно вызывают колбэк очистки, есть вероятность, что они не будут вызваны, например:
- Когда программа полностью завершает свою работу (например, при закрытии вкладки в браузере). 
- Когда сам экземпляр `FinalizationRegistry` больше не доступен для JavaScript кода.

## Совместное использование WeakRef и FinalizationRegistry

Возвращаясь к нашему примеру [слабого кеша](#primer-primenenie-weakref-dlya-keshirovaniya), мы можем заметить следующее:  
- Несмотря на то, что значения, обёрнутые в `WeakRef`, были собраны сборщиком мусора,
всё ещё актуальна проблема "утечки памяти" в виде оставшихся ключей, значения которых были собраны сборщиком мусора.

Вот улучшенный пример слабого кеша, в котором используется `FinalizationRegistry`:

```js
const weakRefCache = (fetchImg) => {
  const imgCache = new Map();
  *!*
  const registry = new FinalizationRegistry((imgName) => { // (1)
    const cachedImg = imgCache.get(imgName);
    if (cachedImg && !cachedImg.deref()) imgCache.delete(imgName);
  });
  */!*
  
  return (imgName) => {
    const cachedImg = imgCache.get(imgName);
    
    if (cachedImg?.deref()) {
      return cachedImg?.deref();
    }

    
    const newImg = fetchImg(imgName);
    imgCache.set(imgName, new WeakRef(newImg));
    *!*
    registry.register(newImg, imgName); // (2)
    */!*

    return newImg;
  };
};

const getCachedImg = weakRefCache(fetchImg);
```

- `(1)` Для управления очисткой "мёртвых" записей в кэше, когда связанные с ними объекты `WeakRef` собираются сборщиком мусора, создаём реестр очистки с использованием конструктора `FinalizationRegistry()`.
  Важным моментом здесь является то, что колбэк должен проверить, что запись была удалена сборщиком мусора и не была добавлена заново, чтобы не удалить "живую" запись.
- `(2)` После загрузки и установки нового значения (изображения) в кэш, регистрируем его в реестре финализатора для отслеживания объекта `WeakRef`.

Данная реализация содержит только актуальные или «живые» пары ключ/значение.
В этом случае каждый объект `WeakRef` зарегистрирован в `FinalizationRegistry`.
А после того, как объекты будут очищены сборщиком мусора, колбэк очистки удалит все значения `undefined`.

Вот визуальное представление обновлённого кода:

![](weakref-finalizationregistry-06.svg)

Важным моментом в реализации выше является то, что финализаторы внедряют параллелизм между "основной" программой и колбэками очистки.
Вышеупомянутый колбэк очистки должен проверить, не была ли запись добавлена обратно в кэш "основной" программой, в моменте между сбором мусора
и выполнением колбэка, чтобы избежать удаления активных ("живых") записей.
Аналогично, при поиске ключа в кэше есть возможность, что значение было собрано сборщиком мусора, но функция очистки еще не была выполнена.

## Совместное использование WeakRef и FinalizationRegistry

```smart header="Примечание"
Интерактивное демо (песочница) будет представлено в конце статьи.
```

Переходя от теории к практике, представьте себе реальный сценарий, когда пользователь синхронизирует свои фотографии на мобильном устройстве
с каким-либо облачным сервисом (таким как [iCloud](https://ru.wikipedia.org/wiki/ICloud) или [Google Photos](https://ru.wikipedia.org/wiki/Google_Фото)), и хочет просматривать их с других устройств.
Подобные сервисы помимо основного функционала просмотра фотографий, предлагают массу дополнительных возможностей, таких как:

- Редактирование фотографий и видео эффекты.
- Создание воспоминаний и альбомов. 
- Монтаж видео из серии фотографий. 
- ...и многое другое.

Одна из возможных функций, которая будет показана в демо — это создание фотоколлажа из выбранных пользователем фотографий.
Конечно, для демонстрационных целей это очень упрощено, и основная суть — показать возможный сценарий совместного использования `WeakRef` и `FinalizationRegistry` в реальной жизни.  

Краткое описание: Мы открываем свою облачную библиотеку фотографий, выбираем нужные фотографии, макет, и нажимаем кнопку "Create collage".
Затем, мы можем скачать созданный коллаж в виде изображения.  

Итак, представим, что мы открыли свою библиотеку фотографий и в левой части экрана видим список миниатюр наших фотографий.
Для увеличения скорости загрузки страницы разумно будет загружать и показывать миниатюры фотографий не в полном размере, а в сжатом качестве.
Но, для создания коллажа из выбранных фотографий, загружать и использовать их в полноразмерном качестве.
На скриншоте ниже мы видим, что внутренний размер миниатюр составляет 240×240 пикселей.
Размер был выбран специально для увеличения скорости загрузки. Кроме того, нам не нужны полноразмерные фотографии в режиме предпросмотра.

![](weakref-finalizationregistry-demo-01.png)  

Давайте представим, что мы хотим создать коллаж из 4 фотографий, выбираем их, и нажимаем кнопку «Create collage».
На этом этапе наша функция `weakCache` проверяет, есть ли нужное изображение в кэше, и если нет,
то скачивает его из облака и помещает в кэш для возможности дальнейшего использования.
И так происходит для каждого выбранного изображения:

![](weakref-finalizationregistry-demo-02.gif)

Обратив внимание на вывод в консоли можно увидеть, какие из фотографий были загружены из облака (синее сообщение с текстом `FETCHED_IMAGE`).
Так как это первая попытка создания коллажа, это означает, что на данном этапе слабый кэш был пуст, а все фотографии были скачаны из облака и помещены в кэш.  

Но, наряду с процессом загрузки изображений, происходит еще и процесс очистки памяти сборщиком мусора.
Обратите внимание на красное сообщение с текстом `CLEANED_IMAGE`.
Это означает, что хранящийся в кэше объект на который мы ссылаемся используя слабую ссылку, был удалён сборщиком мусора.
И наш финализатор выполнился успешно, тем самым удалив ключ, по которому изображение хранилось в кэше. Об этом нас уведомляет красное сообщение в консоли:

![](weakref-finalizationregistry-demo-03.jpg)  

Далее мы понимаем, что нам не нравится получившийся коллаж, и решаем изменить одно из изображений и создать новый.
Для этого достаточно снять выделение с ненужного изображения, выбрать желаемое, и ещё раз нажать кнопку "Create collage":

![](weakref-finalizationregistry-demo-04.gif)  

Но, обратите внимание на зелёное сообщение в консоли с текстом `CACHED_IMAGE`:
на этот раз не все изображения были скачаны из сети, и одно из них было взято из слабого кэша.
Это означает, что на момент создания коллажа сборщик мусора ещё не удалил наше изображение, и мы смело взяли его из кеша,
тем самым сократив количество сетевых запросов и ускорив общее время процесса создания коллажа:

![](weakref-finalizationregistry-demo-05.jpg)

Давайте ещё немного "поиграем", заменив одно из изображений ещё раз и создав новый коллаж:

![](weakref-finalizationregistry-demo-06.gif)  

На этот раз результат ещё более впечатляющий.
Из 4-х выбранных изображений, 3 из них были взяты из слабого кеша, и только одно пришлось скачать из сети.
Снижение нагрузки на сеть составило около 75%. Впечатляет, не правда ли?

![](weakref-finalizationregistry-demo-07.jpg)

Конечно, не следует забывать, что такое поведение не является гарантированным, и зависит от конкретной реализации и работы сборщика мусора.
Это не является постоянным и предсказуемым результатом, а скорее может быть рассмотрено как дополнительная возможность или приятный бонус.
Сразу же возникает вполне логичный вопрос: почему бы нам не использовать обычный кэш, где мы можем сами управлять его сущностями, а не полагаться на сборщик мусора?
Всё верно, в большинстве случаев нет необходимости использовать `WeakRef` и `FinalizationRegistry`.
В данном случае была представлена альтернативная реализация, которая может быть полезной лишь для редких, неординарных сценариев.
Это, скорее, демонстрация возможности и предоставление основы для собственных размышлений и исследований.

```smart header="Примечание"
Для оптимального взаимодействия откройте демо в новом окне в полноэкранном режиме,
а также открыть инструменты разработчика.
```

[codetabs height=420 src="weakref-finalizationregistry"]

## Итого

`WeakRef` - предназначен для создания слабых ссылок на объекты, что позволяет им быть удалёнными из памяти сборщиком мусора, если на них больше нет сильных ссылок.
Это полезно для решения проблемы чрезмерного использования памяти и оптимизации использования системных ресурсов в приложениях.

`FinalizationRegistry` - это средство регистрации колбэков, которые выполняются при уничтожении объектов, на которые больше нет сильных ссылок.
Это позволяет освобождать связанные с объектом ресурсы или выполнять другие необходимые операции перед удалением объекта из памяти.
`FinalizationRegistry` помогает улучшить управление ресурсами и избегать утечек памяти в приложениях JavaScript.