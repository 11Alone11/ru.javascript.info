
# WeakRef и FinalizationRegistry

Вспоминая основную концепцию принципа *достижимости* из главы <info:garbage-collection>,
мы помним что движок JavaScript гарантированно хранит в памяти "достижимые" значения (те, которые доступны или используются).

Например:

```js
//  в переменной user находится сильная ссылка на объект
let user = { name: "Aleks" };

// перезапишем значение переменной user
user = null;

// ссылка теряется и объект будет удалён из памяти
```
Или же, похожий, но немного усложненный пример с двумя сильными ссылками.
Теперь мы скопировали ссылку из `user` в переменную `admin`.
В этом случае объект `Aleks` имеет две сильные ссылки ссылающиеся на него - `user` и `admin`.

```js
//  в переменной user находится сильная ссылка на объект
let user = { name: "Aleks" };

*!*
let admin = user;
*/!*

// перезапишем значение переменной user
user = null;

// объект всё ещё доступен через глобальную переменную admin
```
И только при отсутствии сильных ссылок на объект (если бы мы также перезаписали значение переменной `admin`),
только тогда, объект `Aleks` будет удалён из памяти.  

`WeakRef` - принципиально другая концепция, которая ведёт себя иначе и не предотвращает удаление объектов
сборщиком мусора когда единственными ссылками на объект являются слабые ссылки.

## WeakRef

````warn header="Предостережение"

Прежде чем вы начнёте изучать данные возможности, хотелось бы обратить ваше внимание на официальное предупреждение об их использовании,
которое звучит следующим образом:

```quote
Избегайте, где это возможно.
Правильное использование этих функций требует тщательного обдумывания, и по возможности их лучше избегать.
Также важно не полагаться на какое-либо специфическое поведение, не гарантированное спецификацией.
Лучше всего, если объекты WeakRef и FinalizationRegistry используются как способ избежать чрезмерного использования памяти
или как защита от некоторых ошибок, а не как обычный способ очистки внешних ресурсов или наблюдения за внешними ресурсами.
```

````

`WeakRef` - это объект, содержащий слабую ссылку на другой объект, называемый `target` или `referent`,
который не препятствует сборщику мусора собирать указанный объект.
Другими словами, объект `WeakRef` не удерживает "в живых" объект-референт.  

Теперь давайте используем переменную `user` в качестве референта и создадим слабую ссылку от `user` к переменной `admin`.
Чтобы создать слабую ссылку, необходимо использовать конструктор `WeakRef`,
передав целевой объект (объект, на который вы хотите создать слабую ссылку), в нашем случае это переменная `user`.

```js
//  в переменной user находится сильная ссылка на объект
let user = { name: "Aleks" };

//  в переменной admin находится слабая ссылка на объект
*!*
let admin = new WeakRef(user);
*/!*
```

На картине изображены два типа ссылок: сильная ссылка с использованием переменной `user` и слабая ссылка с использованием переменной `admin`.

![](weakref-finalizationregistry-01.svg)  

Затем, в какой-то момент, мы перестаём использовать переменную `user` - она перезаписывается,
выходит из области видимости и т.д., при этом сохраняя экземпляр `WeakRef` в переменной `admin`.

```js
// перезапишем значение переменной user
user = null;
```
Слабой ссылки на объект не достаточно для того, чтобы сохранить объект в живых.
Когда единственными оставшимися ссылками на референт являются слабые ссылки,
сборщик мусора вправе уничтожить объект и использовать его память для чего-то другого.
Однако до тех пор, пока объект фактически не уничтожен, слабая ссылка может вернуть объект, даже если на него больше нет сильных ссылок.
То есть наш объект становится своеобразным "котом Шрёдингера", о котором мы не можем точно знать, "жив" он или "мёртв".  

![](weakref-finalizationregistry-02.svg)

На этом этапе, чтобы получить объект из экземпляра `WeakRef`, нам следует использовать его метод `deref()`.
Метод `deref()` возвращает объект или `undefined`, если объект больше не доступен.

```js
let ref = admin.deref();

if (ref) {
  // сделать что-нибудь со значением ref
};
```

## Варианты использования WeakRef

`WeakRef` обычно используется для создания кэшей или сопоставлений (mappings), в которых хранятся массивные объекты,
гарантируя, что простое присутствие объекта в кэше или сопоставлении не гарантирует сохранение этих больших объектов в памяти.
Одним из основных примеров является ситуация наличия большого количества объектов бинарных изображений (например, представленных в виде `ArrayBuffer`, `Blob`, и т. д.),
и мы хотим связать имя или путь с каждым изображением. Существующие структуры данных просто не делают то, что здесь требуется.

- Использование `Map` для создания ассоциаций между именами и изображениями, или наоборот, сохранит объекты изображений в памяти,
  поскольку они фигурируют в `Map` в качестве ключей или значений.
- `WeakMap` также не подходит для этой цели: они слабы по своим ключам, но в данном случае нам нужна структура данных, которая была бы слабой по значениям.

Вместо этого мы можем использовать `Map`, значениями которого являются объекты `WeakRef`, ссылающиеся на необходимые большие объекты.
Таким образом, мы избегаем хранения в памяти этих больших и ненужных объектов дольше, чем нужно.
В противном случае это способ получить объект изображения из кэша, если он все еще доступен,
но если он удалён сборщиком мусора, мы сгенерируем или скачаем его заново.
Таким образом, в некоторых ситуациях используется меньше памяти.  

## Пример: применение WeakRef для кеширования

Вот фрагмент кода, который демонстрирует технику использования `WeakRef`.
Кратко говоря, мы используем `Map` со строковыми ключами и объектами `WeakRef` в качестве их значений.
Если объект `WeakRef` не был удалён сборщиком мусора, мы берём его из кэша.
В противном случае мы скачиваем его заново и помещаем в кэш для дальнейшего возможного повторного использования.

```js
const weakRefCache = (fetchImg) => {// (1)
  const imgCache = new Map(); // (2)
  
  return (imgName) => { // (3)
    const cachedImg = imgCache.get(imgName); // (4)
    
    if (cachedImg?.deref() !== undefined) { // (5)
      return cachedImg?.deref();
    }

    
    const newImg = fetchImg(imgName); // (6)
    imgCache.set(imgName, new WeakRef(newImg)); // (7)

    return newImg;
  };
};

const getCachedImg = weakRefCache(fetchImg);
```

Давайте подробно разберём всё, что тут произошло:
- `(1)` `weakRefCache` - функция высшего порядка, которая принимает другую функцию `fetchImg` в качестве аргумента.
- `(2)` `imgCache` - кэш изображений который хранит закэшированные результаты функции `fetchImg`, в виде строковых ключей (имя изображения) и объектов `WeakRef` в качестве их значений.
- `(3)` Возвращаем анонимную функцию, которая принимает имя изображения в качестве аргумента. Данный аргумент будет использоваться в качестве ключа для кэшированного изображения.
- `(4)` Пытаемся получить кэшированный результат из кэша используя предоставленный ключ (имя изображения).
- `(5)` Если кэш содержит значение по указанному ключу, и объект `WeakRef` не был удалён сборщиком мусора, возвращаем закэшированный результат.
- `(6)` Если в кэше нет записи с запрошенным ключом, либо метод `deref()` возвращает `undefined`, что означает что объект `WeakRef` был удалён сборщиком мусора,
  функция `fetchImg` скачивает изображение заново.
- `(7)` Помещаем скачанное изображение в кэш в виде `WeakRef` объекта.  

Вот визуальное представление того, как выглядит этот код.
У нас есть объект `Map`, где ключи - это имена изображений в виде строк, а значения - это объекты `WeakRef`, содержащие сами изображения.
Эта техника помогает избежать выделения большого объема памяти на ресурсоёмкие объекты, которые больше никто не использует.
А также, экономит память и время в случае повторного использования закэшированных объектов.

![](weakref-finalizationregistry-03.svg) 

Но, у данной реализации есть свои недостатки: со временем объект `Map` будет заполняться строками в качестве ключей,
которые указывают на `WeakRef`, чей объект-референт уже был удалён сборщиком мусора.

![](weakref-finalizationregistry-04.svg)

Один из способов справиться с этой проблемой - это периодически проверять кэш и удалять "мёртвые" записи.
Другой способ - использование финализаторов, с которыми мы ознакомися далее.  

## Пример: применение WeakRef для отслеживания объектов DOM

Ещё один вариант использования `WeakRef` - отслеживание объектов DOM.
Давайте представим ситуацию, когда какой-то сторонний код / библиотека работает с элементами на нашей странице до тех пор,
пока они существуют в DOM. Например, это может быть какой-то сторонний логгер, который присылает события в DOM элемент.
Но, как только элемент удаляется из DOM (мы закрыли окно отображения логов), логгер должен перестать слать события.
Для того что б нам не слать лишних событий и не уведомлять сторонний код каждый раз, когда наш элемент доступен и когда он удалён,
достаточно лишь создать на него слабую ссылку. После того как наш элемент будет удалён из DOM (например, пользователь закрывает окно с логами),
логгер это увидит и перестанет слать логи.

```html run height=120
<div class="events">No events.</div>

<script>
  const startLogger = (element) => {
    const timerId = setInterval(() => {
      // Если элемент существует, шлём логи.
      if (element.deref()) {
        const payload = document.createElement("div");
        payload.textContent = `Event: System status OK: ${new Date().toLocaleTimeString()}`;
        element.deref().appendChild(payload);
      } else {
        // Элемент больше не существует, прекращаем отправку.
        clearInterval(timerId);
        alert("The element has been removed.");
      }
    }, 1000);
  };
  
  // Создаём слабую ссылку на элемент и запускаем логгер.
  const eventsElementRef = new WeakRef(document.querySelector(".events"));
  startLogger(eventsElementRef);

  // Через какое-то время элемент исчезает из DOM.
  setTimeout(() => {
    document.querySelector(".events").remove();
  }, 5000);
</script>
```

## FinalizationRegistry

`FinalizationRegistry` предоставляет способ запросить вызов колбэка очистки (также известный как финализатор) в какой-то момент после того,
как объект, зарегистрированный в реестре, будет собран сборщиком мусора.
Чтобы создать реестр, необходимо вызвать его конструктор, передав функцию очистки (финализатор) в качестве аргумента.

```js run
let user = { name: "Aleks" };

const registry = new FinalizationRegistry((heldValue) => {
  console.log(`${heldValue} has been garbage collected.`);
});
```

Затем, мы регистрируем объект для которого требуется колбэк очистки, вызывая метод `register` и передавая объект и `heldValue` значение для него.
Реестр не хранит сильную ссылку на переданный ему объект, так как это противоречило бы цели (если бы реестр сохранял сильную ссылку на объект, то объект никогда бы не был очищен сборщиком мусора).

```js
registry.register(user, user.name);
```

Если объект был собран сборщиком мусора, наш колбэк очистки может быть вызван в какой-то момент в будущем с переданным ему `heldValue`.
Удерживаемое значение (`heldValue`) может быть любого типа: примитив, объект, даже `undefined`.
Если `heldValue` является объектом, реестр срхраняет на него сильную ссылку (чтобы позже можно было передать его в колбэк очистки).  

![](weakref-finalizationregistry-05.svg)

```js
// Когда объект user будет удалён сборщиком мусора, в консоль будет выведено сообщение:
"Aleks has been garbage collected."
```

Также существуют ситуации, когда даже в реализациях, которые обычно вызывают колбэк очистки, есть вероятность, что они не будут вызваны, например:
- Когда программа полностью завершает свою работу (например, при закрытии вкладки в браузере). 
- Когда сам экземпляр `FinalizationRegistry` больше не доступен для JavaScript кода.

## Совместное использование WeakRef и FinalizationRegistry

Возвращаясь к нашему примеру [слабого кэша](#primer-primenenie-weakref-dlya-keshirovaniya) ранее, мы можем заметить следующее:  
Что даже несмотря на то, что значения, обёрнутые в `WeakRef`, были собраны сборщиком мусора,
всё ещё существует "утечка памяти" в виде оставшихся ключей, значения которых были собраны сборщиком мусора.
Для улучшения и устранения ненужных ключей, вот более полная версия слабого кэша, использующая `FinalizationRegistry`.

```js
const weakRefCache = (fetchImg) => {
  const imgCache = new Map();
  *!*
  const registry = new FinalizationRegistry((imgName) => { // (1)
    const cachedImg = imgCache.get(imgName);
    if (cachedImg && !cachedImg.deref()) imgCache.delete(imgName);
  });
  */!*
  
  return (imgName) => {
    const cachedImg = imgCache.get(imgName);
    
    if (cachedImg?.deref() !== undefined) {
      return cachedImg?.deref();
    }

    
    const newImg = fetchImg(imgName);
    imgCache.set(imgName, new WeakRef(newImg));
    *!*
    registry.register(newImg, imgName); // (2)
    */!*

    return newImg;
  };
};

const getCachedImg = weakRefCache(fetchImg);
```

- `(1)` Для управления очисткой "мертвых" записей в кэше, когда связанные с ними объекты `WeakRef` собираются сборщиком мусора, создаём реестр очистки с использованием конструктора `FinalizationRegistry()`.
  Важным моментом здесь является то, что колбэк должен проверить, что запись была удалена сборщиком мусора и не была добавлена заново, чтобы не удалить "живую" запись.
- `(2)` После загрузки и установки нового значения (изображения) в кэш, регистрируем его в реестре финализатора для мониторинга объекта `WeakRef`.

Вот визуальное представление обновлённого кода.
Данная реализация содержит только актуальные или «живые» пары ключ-значение.
В этом случае каждый объект `WeakRef` зарегистрирован в `FinalizationRegistry`.
А после того, как объекты были очищены сборщиком мусора, колбэк очистки удалил все значения `undefined`.

![](weakref-finalizationregistry-06.svg)

Важным моментом в реализации выше является то, что финализаторы внедряют параллелизм между "основной" программой и колбэками очистки.
Вышеупомянутый колбэк очистки, должен проверить, не добавлена ли запись обратно в кэш "основной" программой между моментом сбора мусора,
и моментом выполнения колбэка, чтобы избежать удаления активных записей.
Аналогично, при поиске ключа в кэше есть возможность, что значение было собрано сборщиком мусора, но функция очистки еще не была выполнена.

## Демо совместного использования WeakRef и FinalizationRegistry

```smart header="Примечание"
Интерактивное демо (песочница) будет представлено в конце раздела.
```

Переходя от теории к практике, представьте себе реальный сценарий, когда пользователь синхронизирует свои фотографии на мобильном устройстве
с каким-либо облачным сервисом (таким как iCloud или Google Photos), и хочет просматривать их с других устройств.
Подобные сервисы, помимо основного функционала просмотра фотографий, предлагают массу дополнительных возможностей, таких как:

- Редактирование фотографий и видео эффекты.
- Создание воспоминаний и альбомов. 
- Монтаж видео из серии фотографий. 
- И многое другое.

Одна из возможных функций, которая будет показана в демо — это создание фото коллажа из выбранных пользователем фотографий.
Конечно, для демонстрационных целей это очень упрощено, и основная цель — показать возможный сценарий совместного использования `WeakRef` и `FinalizationRegistry` в реальной жизни.  

Краткое описание: Мы открываем свою облачную библиотеку фотографий, выбираем нужные фотографии, макет, и нажимаем кнопку "Create collage".
Затем, мы можем скачать созданный коллаж в виде изображения.  

Итак, представим, что мы открыли свою библиотеку фотографий и в левой части экрана видим список миниатюр наших фотографий.
Для увеличения скорости загрузки страницы разумно будет загружать и показывать миниатюры фотографий не в полном размере, а в сжатом качестве.
Но, для создания коллажа из выбранных фотографий, загружать и использовать их в полноразмерном качестве.
На этом скриншоте мы видим, что внутренний размер миниатюр составляет 240×240 пикселей.
Размер был выбран специально для увеличения скорости загрузки, а также за ненадобностью иметь полноразмерные фотографии в качестве предосмотра.  

![](weakref-finalizationregistry-demo-01.png)  

Давайте представим, что мы хотим создать коллаж из 4-х фотографий, выбираем их, и нажимаем кнопку «Create collage».
На этом этапе наша функция `weakCache` проверяет, есть ли нужное изображение в кэше, и если нет,
то скачивает его из облака и помещает в кэш для возможного дальнейшего использования.
И так происходит для каждого выбранного изображения.

![](weakref-finalizationregistry-demo-02.gif)

Из вывода в консоли видно, какие из фотографий были загружены из облака (синее сообщение с текстом `FETCHED_IMAGE`).
Так как это первая попытка создания коллажа, это означает, что на данном этапе слабый кэш был пуст, а все фотографии были скачаны из облака и помещены в кэш.  

Но, наряду с процессом загрузки изображений, происходит еще и процесс очистки памяти сборщиком мусора.
Обратите внимание на красное сообщение с текстом `CLEANED_IMAGE`.
Это означает, что хранящийся в кэше объект на который мы ссылаемся используя слабую ссылку, был удалён сборщиком мусора.
И наш финализатор выполнился успешно, тем самым удалив ключ, по которому изображение хранилось в кэше, и оповестив нас красным сообщением в консоль.  

![](weakref-finalizationregistry-demo-03.jpg)  

Далее мы понимаем, что нам не нравится получившийся коллаж, и решаем изменить одно из изображений и создать новый.
Для этого достаточно снять выделение с не желаемого изображения, выбрать нужное, и ещё раз нажать кнопку "Create collage".  

![](weakref-finalizationregistry-demo-04.gif)  

Но, обратите внимание на зелёное сообщение в консоли с текстом `CACHED_IMAGE`,
на этот раз не все изображения были скачаны из сети, и одно из них было взято из слабого кэша.
Это означает, что на момент создания коллажа сборщик мусора ещё не удалил наше изображение, и мы смело использовали его из кэша,
тем самым сократив количество сетевых запросов и ускорив общее время процесса создания коллажа.  

![](weakref-finalizationregistry-demo-05.jpg)

Давайте ещё немного "поиграем", заменив одно из изображений ещё раз и создадим новый коллаж.  

![](weakref-finalizationregistry-demo-06.gif)  

На этот раз результат ещё более впечатляющий.
Из 4-х выбранных изображений, 3 из них были взяты из слабого кеша, и только одно пришлось скачать из сети.
Снижение нагрузки на сеть составило ~ 75%, впечатляет, не правда ли?

![](weakref-finalizationregistry-demo-07.jpg)

Конечно, не следует забывать, что такое поведение не является гарантированным, и зависит от конкретной реализации и работы сборщика мусора.
Это не является постоянным и предсказуемым результатом, а скорее может быть рассмотрено как дополнительная возможность или приятный бонус.
Сразу же возникает вполне логичный вопрос: почему бы нам не использовать обычный кэш, где мы можем сами управлять его сущностями, а не полагаться на сборщика мусора?
Всё верно, в большинстве случаев нет необходимости использовать `WeakRef`.
В данном случае была представлена альтернативная концепция, которая может быть полезной для определенных сценариев.
Это, скорее, демонстрация возможности и предоставление основы для собственных размышлений и реализаций.

```smart header="Примечание"
Для оптимального взаимодействия, рекомендуем вам открыть демо в новом окне в полноэкранном режиме,
а также открыть инструменты разработчика.
```

[codetabs height=420 src="weakref-finalizationregistry"]

## Итого

`WeakRef` - предназначенный для создания слабых ссылок на объекты, что позволяет объектам быть удалёнными из памяти сборщиком мусора, если на них больше нет сильных ссылок.
Это полезно для решения проблемы чрезмерного использования памяти и оптимизации использования системных ресурсов в приложениях.

`FinalizationRegistry` - это средство для регистрации колбэков, которые выполняются при уничтожении объектов, на которые больше нет сильных ссылок.
Это позволяет освобождать связанные с объектом ресурсы или выполнять другие необходимые операции перед удалением объекта из памяти.
`FinalizationRegistry` помогает улучшить управление ресурсами и избегать утечек памяти в приложениях JavaScript.